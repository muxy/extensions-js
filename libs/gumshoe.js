/* eslint-disable */

// polyfill for String.prototype.trim for IE8
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim
if (!String.prototype.trim) {
  (function () {
    // Make sure we trim BOM and NBSP
    var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    String.prototype.trim = function () {
      return this.replace(rtrim, '');
    };
  })();
}

// Production steps of ECMA-262, Edition 5, 15.4.4.21
// Reference: http://es5.github.io/#x15.4.4.21
if (!Array.prototype.reduce) {
  Array.prototype.reduce = function (callback /*, initialValue*/) {
    'use strict';
    if (this == null) {
      throw new TypeError('Array.prototype.reduce called on null or undefined');
    }
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }
    var t = Object(this),
      len = t.length >>> 0,
      k = 0,
      value;
    if (arguments.length == 2) {
      value = arguments[1];
    } else {
      while (k < len && !k in t) {
        k++;
      }
      if (k >= len) {
        throw new TypeError('Reduce of empty array with no initial value');
      }
      value = t[k++];
    }
    for (; k < len; k++) {
      if (k in t) {
        value = callback(value, t[k], k, t);
      }
    }
    return value;
  };
}

/**
 * @file perfnow is a 0.14 kb window.performance.now high resolution timer polyfill with Date fallback
 * @author Daniel Lamb <dlamb.open.source@gmail.com>
 */
function perfnow() {
  var perf = window.performance || {};
  perf.now =
    perf.now ||
    perf.mozNow ||
    perf.msNow ||
    perf.oNow ||
    perf.webkitNow ||
    // fallback to Date
    Date.now ||
    function () {
      return new Date().getTime();
    };

  return perf;
}

function gumshoeFactory() {
  'use strict';

  // we need reqwest and store2 (and any other future deps)
  // to be solely within our context, so as they don't leak and conflict
  // with other versions of the same libs sites may be loading.
  // so we'll provide our own context.
  // root._gumshoe is only available in specs
  var context = {},
    queryString,
    store,
    /*jshint -W024 */
    undefined;

  // call contextSetup with 'context' as 'this' so all libs attach
  // to our context variable.
  (function contextSetup() {
    /*!
	    query-string
	    Parse and stringify URL query strings
	    https://github.com/sindresorhus/query-string
	    by Sindre Sorhus
	    MIT License
    */
    (function (c) {
      'use strict';
      var queryString = {};

      queryString.parse = function (str) {
        if (typeof str !== 'string') {
          return {};
        }

        str = str.trim().replace(/^(\?|#)/, '');

        if (!str) {
          return {};
        }

        return str
          .trim()
          .split('&')
          .reduce(function (ret, param) {
            var parts = param.replace(/\+/g, ' ').split('=');
            var key = parts[0];
            var val = parts[1];

            key = decodeURIComponent(key);
            // missing `=` should be `null`:
            // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
            val = val === undefined ? null : decodeURIComponent(val);

            if (!ret.hasOwnProperty(key)) {
              ret[key] = val;
            } else if (Array.isArray(ret[key])) {
              ret[key].push(val);
            } else {
              ret[key] = [ret[key], val];
            }

            return ret;
          }, {});
      };

      queryString.stringify = function (obj) {
        return obj
          ? Object.keys(obj)
              .map(function (key) {
                var val = obj[key];

                if (Array.isArray(val)) {
                  return val
                    .map(function (val2) {
                      return encodeURIComponent(key) + '=' + encodeURIComponent(val2);
                    })
                    .join('&');
                }

                return encodeURIComponent(key) + '=' + encodeURIComponent(val);
              })
              .join('&')
          : '';
      };

      c.queryString = queryString;
    })(this);

    /*!
     * Reqwest! A general purpose XHR connection manager
     * license MIT (c) Dustin Diaz 2014
     * https://github.com/ded/reqwest
     */

    !(function (name, context, definition) {
      context[name] = definition();
    })('reqwest', this, function () {
      var win = window,
        doc = document,
        httpsRe = /^http/,
        protocolRe = /(^\w+):\/\//,
        twoHundo = /^(20\d|1223)$/, //http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
        byTag = 'getElementsByTagName',
        readyState = 'readyState',
        contentType = 'Content-Type',
        requestedWith = 'X-Requested-With',
        head = doc[byTag]('head')[0],
        uniqid = 0,
        callbackPrefix = 'reqwest_' + +new Date(),
        lastValue, // data stored by the most recent JSONP callback
        xmlHttpRequest = 'XMLHttpRequest',
        xDomainRequest = 'XDomainRequest',
        noop = function () {},
        isArray =
          typeof Array.isArray == 'function'
            ? Array.isArray
            : function (a) {
                return a instanceof Array;
              },
        defaultHeaders = {
          contentType: 'application/x-www-form-urlencoded',
          requestedWith: xmlHttpRequest,
          accept: {
            '*': 'text/javascript, text/html, application/xml, text/xml, */*',
            xml: 'application/xml, text/xml',
            html: 'text/html',
            text: 'text/plain',
            json: 'application/json, text/javascript',
            js: 'application/javascript, text/javascript'
          }
        },
        xhr = function (o) {
          // is it x-domain
          if (o['crossOrigin'] === true) {
            var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null;
            if (xhr && 'withCredentials' in xhr) {
              return xhr;
            } else if (win[xDomainRequest]) {
              return new XDomainRequest();
            } else {
              throw new Error('Browser does not support cross-origin requests');
            }
          } else if (win[xmlHttpRequest]) {
            return new XMLHttpRequest();
          } else {
            return new ActiveXObject('Microsoft.XMLHTTP');
          }
        },
        globalSetupOptions = {
          dataFilter: function (data) {
            return data;
          }
        };

      function succeed(r) {
        var protocol = protocolRe.exec(r.url);
        protocol = (protocol && protocol[1]) || window.location.protocol;
        return httpsRe.test(protocol) ? twoHundo.test(r.request.status) : !!r.request.responseText;
      }

      function handleReadyState(r, success, error) {
        return function () {
          // use _aborted to mitigate against IE err c00c023f
          // (can't read props on aborted request objects)
          if (r._aborted) return error(r.request);
          if (r._timedOut) return error(r.request, 'Request is aborted: timeout');
          if (r.request && r.request[readyState] == 4) {
            r.request.onreadystatechange = noop;
            if (succeed(r)) success(r.request);
            else error(r.request);
          }
        };
      }

      function setHeaders(http, o) {
        var headers = o['headers'] || {},
          h;

        headers['Accept'] = headers['Accept'] || defaultHeaders['accept'][o['type']] || defaultHeaders['accept']['*'];

        var isAFormData = typeof FormData === 'function' && o['data'] instanceof FormData;
        // breaks cross-origin requests with legacy browsers
        if (!o['crossOrigin'] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith'];
        if (!headers[contentType] && !isAFormData)
          headers[contentType] = o['contentType'] || defaultHeaders['contentType'];
        for (h in headers)
          headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h]);
      }

      function setCredentials(http, o) {
        if (typeof o['withCredentials'] !== 'undefined' && typeof http.withCredentials !== 'undefined') {
          http.withCredentials = !!o['withCredentials'];
        }
      }

      function generalCallback(data) {
        lastValue = data;
      }

      function urlappend(url, s) {
        return url + (/\?/.test(url) ? '&' : '?') + s;
      }

      function handleJsonp(o, fn, err, url) {
        var reqId = uniqid++,
          cbkey = o['jsonpCallback'] || 'callback', // the 'callback' key
          cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId),
          cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)'),
          match = url.match(cbreg),
          script = doc.createElement('script'),
          loaded = 0,
          isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1;

        if (match) {
          if (match[3] === '?') {
            url = url.replace(cbreg, '$1=' + cbval); // wildcard callback func name
          } else {
            cbval = match[3]; // provided callback func name
          }
        } else {
          url = urlappend(url, cbkey + '=' + cbval); // no callback details, add 'em
        }

        win[cbval] = generalCallback;

        script.type = 'text/javascript';
        script.src = url;
        script.async = true;
        if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
          // need this for IE due to out-of-order onreadystatechange(), binding script
          // execution to an event listener gives us control over when the script
          // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
          script.htmlFor = script.id = '_reqwest_' + reqId;
        }

        script.onload = script.onreadystatechange = function () {
          if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
            return false;
          }
          script.onload = script.onreadystatechange = null;
          script.onclick && script.onclick();
          // Call the user callback with the last value stored and clean up values and scripts.
          fn(lastValue);
          lastValue = undefined;
          head.removeChild(script);
          loaded = 1;
        };

        // Add the script to the DOM head
        head.appendChild(script);

        // Enable JSONP timeout
        return {
          abort: function () {
            script.onload = script.onreadystatechange = null;
            err({}, 'Request is aborted: timeout', {});
            lastValue = undefined;
            head.removeChild(script);
            loaded = 1;
          }
        };
      }

      function getRequest(fn, err) {
        var o = this.o,
          method = (o['method'] || 'GET').toUpperCase(),
          url = typeof o === 'string' ? o : o['url'],
          // convert non-string objects to query-string form unless o['processData'] is false
          data =
            o['processData'] !== false && o['data'] && typeof o['data'] !== 'string'
              ? reqwest.toQueryString(o['data'])
              : o['data'] || null,
          http,
          sendWait = false;

        // if we're working on a GET request and we have data then we should append
        // query string to end of URL and not post data
        if ((o['type'] == 'jsonp' || method == 'GET') && data) {
          url = urlappend(url, data);
          data = null;
        }

        if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url);

        // get the xhr from the factory if passed
        // if the factory returns null, fall-back to ours
        http = (o.xhr && o.xhr(o)) || xhr(o);

        http.open(method, url, o['async'] === false ? false : true);
        setHeaders(http, o);
        setCredentials(http, o);
        if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
          http.onload = fn;
          http.onerror = err;
          // NOTE: see
          // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e
          http.onprogress = function () {};
          sendWait = true;
        } else {
          http.onreadystatechange = handleReadyState(this, fn, err);
        }
        o['before'] && o['before'](http);
        if (sendWait) {
          setTimeout(function () {
            http.send(data);
          }, 200);
        } else {
          http.send(data);
        }
        return http;
      }

      function Reqwest(o, fn) {
        this.o = o;
        this.fn = fn;

        init.apply(this, arguments);
      }

      function setType(header) {
        // json, javascript, text/plain, text/html, xml
        if (header.match('json')) return 'json';
        if (header.match('javascript')) return 'js';
        if (header.match('text')) return 'html';
        if (header.match('xml')) return 'xml';
      }

      function init(o, fn) {
        this.url = typeof o == 'string' ? o : o['url'];
        this.timeout = null;

        // whether request has been fulfilled for purpose
        // of tracking the Promises
        this._fulfilled = false;
        // success handlers
        this._successHandler = function () {};
        this._fulfillmentHandlers = [];
        // error handlers
        this._errorHandlers = [];
        // complete (both success and fail) handlers
        this._completeHandlers = [];
        this._erred = false;
        this._responseArgs = {};

        var self = this;

        fn = fn || function () {};

        if (o['timeout']) {
          this.timeout = setTimeout(function () {
            timedOut();
          }, o['timeout']);
        }

        if (o['success']) {
          this._successHandler = function () {
            o['success'].apply(o, arguments);
          };
        }

        if (o['error']) {
          this._errorHandlers.push(function () {
            o['error'].apply(o, arguments);
          });
        }

        if (o['complete']) {
          this._completeHandlers.push(function () {
            o['complete'].apply(o, arguments);
          });
        }

        function complete(resp) {
          o['timeout'] && clearTimeout(self.timeout);
          self.timeout = null;
          while (self._completeHandlers.length > 0) {
            self._completeHandlers.shift()(resp);
          }
        }

        function success(resp) {
          var type = o['type'] || (resp && setType(resp.getResponseHeader('Content-Type'))); // resp can be undefined in IE
          resp = type !== 'jsonp' ? self.request : resp;
          // use global data filter on response text
          var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type),
            r = filteredResponse;
          try {
            resp.responseText = r;
          } catch (e) {
            // can't assign this in IE<=8, just ignore
          }
          if (r) {
            switch (type) {
              case 'json':
                try {
                  resp = win.JSON.parse(r);
                } catch (err) {
                  return error(resp, 'Could not parse JSON in response', err);
                }
                break;
            }
          }

          self._responseArgs.resp = resp;
          self._fulfilled = true;
          fn(resp);
          self._successHandler(resp);
          while (self._fulfillmentHandlers.length > 0) {
            resp = self._fulfillmentHandlers.shift()(resp);
          }

          complete(resp);
        }

        function timedOut() {
          self._timedOut = true;
          if (typeof self.request !== 'undefined' && typeof self.request.abort === 'function') {
            self.request.abort();
          }
        }

        function error(resp, msg, t) {
          resp = self.request;
          self._responseArgs.resp = resp;
          self._responseArgs.msg = msg;
          self._responseArgs.t = t;
          self._erred = true;
          while (self._errorHandlers.length > 0) {
            self._errorHandlers.shift()(resp, msg, t);
          }
          complete(resp);
        }

        this.request = getRequest.call(this, success, error);
      }

      Reqwest.prototype = {
        abort: function () {
          this._aborted = true;
          if (typeof this.request !== 'undefined' && typeof this.request.abort === 'function') {
            this.request.abort();
          }
        },

        retry: function () {
          this._aborted = false;
          this._timedOut = false;
          init.call(this, this.o, this.fn);
        },

        /**
         * Small deviation from the Promises A CommonJs specification
         * http://wiki.commonjs.org/wiki/Promises/A
         */

        /**
         * `then` will execute upon successful requests
         */
        then: function (success, fail) {
          success = success || function () {};
          fail = fail || function () {};
          if (this._fulfilled) {
            this._responseArgs.resp = success(this._responseArgs.resp);
          } else if (this._erred) {
            fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t);
          } else {
            this._fulfillmentHandlers.push(success);
            this._errorHandlers.push(fail);
          }
          return this;
        },

        /**
         * `always` will execute whether the request succeeds or fails
         */
        always: function (fn) {
          if (this._fulfilled || this._erred) {
            fn(this._responseArgs.resp);
          } else {
            this._completeHandlers.push(fn);
          }
          return this;
        },

        /**
         * `fail` will execute when the request fails
         */
        fail: function (fn) {
          if (this._erred) {
            fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t);
          } else {
            this._errorHandlers.push(fn);
          }
          return this;
        },
        catch: function (fn) {
          return this.fail(fn);
        }
      };

      function reqwest(o, fn) {
        return new Reqwest(o, fn);
      }

      // normalize newline variants according to spec -> CRLF
      function normalize(s) {
        return s ? s.replace(/\r?\n/g, '\r\n') : '';
      }

      function serial(el, cb) {
        var n = el.name,
          t = el.tagName.toLowerCase(),
          optCb = function (o) {
            // IE gives value="" even where there is no value attribute
            // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
            if (o && !o['disabled'])
              cb(
                n,
                normalize(o['attributes']['value'] && o['attributes']['value']['specified'] ? o['value'] : o['text'])
              );
          },
          ch,
          ra,
          val,
          i;

        // don't serialize elements that are disabled or without a name
        if (el.disabled || !n) return;

        switch (t) {
          case 'input':
            if (!/reset|button|image|file/i.test(el.type)) {
              ch = /checkbox/i.test(el.type);
              ra = /radio/i.test(el.type);
              val = el.value;
              // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
              (!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val));
            }
            break;
          case 'textarea':
            cb(n, normalize(el.value));
            break;
          case 'select':
            if (el.type.toLowerCase() === 'select-one') {
              optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null);
            } else {
              for (i = 0; el.length && i < el.length; i++) {
                el.options[i].selected && optCb(el.options[i]);
              }
            }
            break;
        }
      }

      // collect up all form elements found from the passed argument elements all
      // the way down to child elements; pass a '<form>' or form fields.
      // called with 'this'=callback to use for serial() on each element
      function eachFormElement() {
        var cb = this,
          e,
          i,
          serializeSubtags = function (e, tags) {
            var i, j, fa;
            for (i = 0; i < tags.length; i++) {
              fa = e[byTag](tags[i]);
              for (j = 0; j < fa.length; j++) serial(fa[j], cb);
            }
          };

        for (i = 0; i < arguments.length; i++) {
          e = arguments[i];
          if (/input|select|textarea/i.test(e.tagName)) serial(e, cb);
          serializeSubtags(e, ['input', 'select', 'textarea']);
        }
      }

      // standard query string style serialization
      function serializeQueryString() {
        return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments));
      }

      // { 'name': 'value', ... } style serialization
      function serializeHash() {
        var hash = {};
        eachFormElement.apply(function (name, value) {
          if (name in hash) {
            hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]]);
            hash[name].push(value);
          } else hash[name] = value;
        }, arguments);
        return hash;
      }

      // [ { name: 'name', value: 'value' }, ... ] style serialization
      reqwest.serializeArray = function () {
        var arr = [];
        eachFormElement.apply(function (name, value) {
          arr.push({ name: name, value: value });
        }, arguments);
        return arr;
      };

      reqwest.serialize = function () {
        if (arguments.length === 0) return '';
        var opt,
          fn,
          args = Array.prototype.slice.call(arguments, 0);

        opt = args.pop();
        opt && opt.nodeType && args.push(opt) && (opt = null);
        opt && (opt = opt.type);

        if (opt == 'map') fn = serializeHash;
        else if (opt == 'array') fn = reqwest.serializeArray;
        else fn = serializeQueryString;

        return fn.apply(null, args);
      };

      reqwest.toQueryString = function (o, trad) {
        var prefix,
          i,
          traditional = trad || false,
          s = [],
          enc = encodeURIComponent,
          add = function (key, value) {
            // If value is a function, invoke it and return its value
            value = 'function' === typeof value ? value() : value == null ? '' : value;
            s[s.length] = enc(key) + '=' + enc(value);
          };
        // If an array was passed in, assume that it is an array of form elements.
        if (isArray(o)) {
          for (i = 0; o && i < o.length; i++) add(o[i]['name'], o[i]['value']);
        } else {
          // If traditional, encode the "old" way (the way 1.3.2 or older
          // did it), otherwise encode params recursively.
          for (prefix in o) {
            if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add);
          }
        }

        // spaces should be + according to spec
        return s.join('&').replace(/%20/g, '+');
      };

      function buildParams(prefix, obj, traditional, add) {
        var name,
          i,
          v,
          rbracket = /\[\]$/;

        if (isArray(obj)) {
          // Serialize array item.
          for (i = 0; obj && i < obj.length; i++) {
            v = obj[i];
            if (traditional || rbracket.test(prefix)) {
              // Treat each array item as a scalar.
              add(prefix, v);
            } else {
              buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
            }
          }
        } else if (obj && obj.toString() === '[object Object]') {
          // Serialize object item.
          for (name in obj) {
            buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
          }
        } else {
          // Serialize scalar item.
          add(prefix, obj);
        }
      }

      reqwest.getcallbackPrefix = function () {
        return callbackPrefix;
      };

      // jQuery and Zepto compatibility, differences can be remapped here so you can call
      // .ajax.compat(options, callback)
      reqwest.compat = function (o, fn) {
        if (o) {
          o['type'] && (o['method'] = o['type']) && delete o['type'];
          o['dataType'] && (o['type'] = o['dataType']);
          o['jsonpCallback'] && (o['jsonpCallbackName'] = o['jsonpCallback']) && delete o['jsonpCallback'];
          o['jsonp'] && (o['jsonpCallback'] = o['jsonp']);
        }
        return new Reqwest(o, fn);
      };

      reqwest.ajaxSetup = function (options) {
        options = options || {};
        for (var k in options) {
          globalSetupOptions[k] = options[k];
        }
      };

      return reqwest;
    });

    /*! store2 - v2.3.0 - 2015-05-22
     * Copyright (c) 2015 Nathan Bubna; Licensed MIT, GPL */
    (function (window, define) {
      var _ = {
        version: '2.3.0',
        areas: {},
        apis: {},

        // utilities
        inherit: function (api, o) {
          for (var p in api) {
            if (!o.hasOwnProperty(p)) {
              o[p] = api[p];
            }
          }
          return o;
        },
        stringify: function (d) {
          return d === undefined || typeof d === 'function' ? d + '' : JSON.stringify(d);
        },
        parse: function (s) {
          // if it doesn't parse, return as is
          try {
            return JSON.parse(s);
          } catch (e) {
            return s;
          }
        },

        // extension hooks
        fn: function (name, fn) {
          _.storeAPI[name] = fn;
          for (var api in _.apis) {
            _.apis[api][name] = fn;
          }
        },
        get: function (area, key) {
          return area.getItem(key);
        },
        set: function (area, key, string) {
          area.setItem(key, string);
        },
        remove: function (area, key) {
          area.removeItem(key);
        },
        key: function (area, i) {
          return area.key(i);
        },
        length: function (area) {
          return area.length;
        },
        clear: function (area) {
          area.clear();
        },

        // core functions
        Store: function (id, area, namespace) {
          var store = _.inherit(_.storeAPI, function (key, data, overwrite) {
            if (arguments.length === 0) {
              return store.getAll();
            }
            if (data !== undefined) {
              return store.set(key, data, overwrite);
            }
            if (typeof key === 'string') {
              return store.get(key);
            }
            if (!key) {
              return store.clear();
            }
            return store.setAll(key, data); // overwrite=data, data=key
          });
          store._id = id;
          try {
            var testKey = '_safariPrivate_';
            area.setItem(testKey, 'sucks');
            store._area = area;
            area.removeItem(testKey);
          } catch (e) {}
          if (!store._area) {
            store._area = _.inherit(_.storageAPI, { items: {}, name: 'fake' });
          }
          store._ns = namespace || '';
          if (!_.areas[id]) {
            _.areas[id] = store._area;
          }
          if (!_.apis[store._ns + store._id]) {
            _.apis[store._ns + store._id] = store;
          }
          return store;
        },
        storeAPI: {
          // admin functions
          area: function (id, area) {
            var store = this[id];
            if (!store || !store.area) {
              store = _.Store(id, area, this._ns); //new area-specific api in this namespace
              if (!this[id]) {
                this[id] = store;
              }
            }
            return store;
          },
          namespace: function (namespace, noSession) {
            if (!namespace) {
              return this._ns ? this._ns.substring(0, this._ns.length - 1) : '';
            }
            var ns = namespace,
              store = this[ns];
            if (!store || !store.namespace) {
              store = _.Store(this._id, this._area, this._ns + ns + '.'); //new namespaced api
              if (!this[ns]) {
                this[ns] = store;
              }
              if (!noSession) {
                store.area('session', _.areas.session);
              }
            }
            return store;
          },
          isFake: function () {
            return this._area.name === 'fake';
          },
          toString: function () {
            return 'store' + (this._ns ? '.' + this.namespace() : '') + '[' + this._id + ']';
          },

          // storage functions
          has: function (key) {
            if (this._area.has) {
              return this._area.has(this._in(key)); //extension hook
            }
            return !!(this._in(key) in this._area);
          },
          size: function () {
            return this.keys().length;
          },
          each: function (fn, and) {
            for (var i = 0, m = _.length(this._area); i < m; i++) {
              var key = this._out(_.key(this._area, i));
              if (key !== undefined) {
                if (fn.call(this, key, and || this.get(key)) === false) {
                  break;
                }
              }
              if (m > _.length(this._area)) {
                m--;
                i--;
              } // in case of removeItem
            }
            return and || this;
          },
          keys: function () {
            return this.each(function (k, list) {
              list.push(k);
            }, []);
          },
          get: function (key, alt) {
            var s = _.get(this._area, this._in(key));
            return s !== null ? _.parse(s) : alt || s; // support alt for easy default mgmt
          },
          getAll: function () {
            return this.each(function (k, all) {
              all[k] = this.get(k);
            }, {});
          },
          set: function (key, data, overwrite) {
            var d = this.get(key);
            if (d != null && overwrite === false) {
              return data;
            }
            return _.set(this._area, this._in(key), _.stringify(data), overwrite) || d;
          },
          setAll: function (data, overwrite) {
            var changed, val;
            for (var key in data) {
              val = data[key];
              if (this.set(key, val, overwrite) !== val) {
                changed = true;
              }
            }
            return changed;
          },
          remove: function (key) {
            var d = this.get(key);
            _.remove(this._area, this._in(key));
            return d;
          },
          clear: function () {
            if (!this._ns) {
              _.clear(this._area);
            } else {
              this.each(function (k) {
                _.remove(this._area, this._in(k));
              }, 1);
            }
            return this;
          },
          clearAll: function () {
            var area = this._area;
            for (var id in _.areas) {
              if (_.areas.hasOwnProperty(id)) {
                this._area = _.areas[id];
                this.clear();
              }
            }
            this._area = area;
            return this;
          },

          // internal use functions
          _in: function (k) {
            if (typeof k !== 'string') {
              k = _.stringify(k);
            }
            return this._ns ? this._ns + k : k;
          },
          _out: function (k) {
            return this._ns
              ? k && k.indexOf(this._ns) === 0
                ? k.substring(this._ns.length)
                : undefined // so each() knows to skip it
              : k;
          }
        }, // end _.storeAPI
        storageAPI: {
          length: 0,
          has: function (k) {
            return this.items.hasOwnProperty(k);
          },
          key: function (i) {
            var c = 0;
            for (var k in this.items) {
              if (this.has(k) && i === c++) {
                return k;
              }
            }
          },
          setItem: function (k, v) {
            if (!this.has(k)) {
              this.length++;
            }
            this.items[k] = v;
          },
          removeItem: function (k) {
            if (this.has(k)) {
              delete this.items[k];
              this.length--;
            }
          },
          getItem: function (k) {
            return this.has(k) ? this.items[k] : null;
          },
          clear: function () {
            for (var k in this.list) {
              this.removeItem(k);
            }
          },
          toString: function () {
            return this.length + ' items in ' + this.name + 'Storage';
          }
        } // end _.storageAPI
      };

      // setup the primary store fn
      if (window.store) {
        _.conflict = window.store;
      }
      var store =
        // safely set this up (throws error in IE10/32bit mode for local files)
        _.Store('local');
      store.local = store; // for completeness
      store._ = _; // for extenders and debuggers...
      // safely setup store.session (throws exception in FF for file:/// urls)
      store.area('session');

      //Expose store to the global object
      window.store = store;

      if (typeof define === 'function' && define.amd !== undefined) {
        define(function () {
          return store;
        });
      } else if (typeof module !== 'undefined' && module.exports) {
        module.exports = store;
      }
    })(this, this.define);
  }.call(context));

  queryString = context.queryString;
  store = context.store;

  function extend(obj) {
    if (!isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        obj[prop] = source[prop];
      }
    }
    return obj;
  }

  function isArray(obj) {
    return '[object Array]' === Object.prototype.toString.call(obj);
  }

  function isFunction(obj) {
    return '' + typeof obj === 'function';
  }

  function isObject(obj) {
    var type = typeof obj;
    return type === 'function' || (type === 'object' && !!obj);
  }

  function isString(value) {
    return (
      typeof value == 'string' ||
      (value && typeof value == 'object' && Object.prototype.toString.call(value) == '[object String]') ||
      false
    );
  }

  function uuidv4() {
    var d = perfnow().now();
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = (d + Math.random() * 16) % 16 | 0;
      d = Math.floor(d / 16);
      return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);
    });
    return uuid;
  }

  var defaults = {
      transport: '',
      queueTimeout: 100
    },
    localStore = store.namespace('gumshoe'),
    storage = store.namespace('gumshoe').session,
    queue = storage('queue') || [],
    transports = {};

  if (!isArray(queue)) {
    queue = [];
  }

  function gumshoe(options) {
    var clientUuid = localStore('clientUuid');

    options = extend({}, defaults, options);

    // always ensure options.transport is an array.
    if (isString(options.transport)) {
      options.transport = [options.transport];
    } else if (!isArray(options.transport)) {
      throw 'Gumeshoe: Transport property must be a [String] or [Array].';
    }

    // store a client id to identify a client long-term. Google Analytics uses
    // the value, combined with other factors, to determine unique users. we
    // duplicate the same kind of value to assist GA.
    if (!clientUuid) {
      clientUuid = uuidv4();
      localStore({ clientUuid: clientUuid });
    }

    options.clientUuid = clientUuid;

    session(options.sessionFn);

    gumshoe.options = options;
  }

  function each(obj, iterator, context) {
    if (obj === null) {
      return;
    }

    if (Array.prototype.forEach && obj.forEach === Array.prototype.forEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === {}) {
          return;
        }
      }
    } else {
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          if (iterator.call(context, obj[key], key, obj) === {}) {
            return;
          }
        }
      }
    }
  }

  function map(obj, iterator, context) {
    var results = [];

    if (!obj) {
      return results;
    }

    if (Array.prototype.map && obj.map === Array.prototype.map) {
      return obj.map(iterator, context);
    }

    each(obj, function (value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });

    return results;
  }

  function collectPlugins() {
    var result,
      plugins = navigator.plugins || [];

    result = map(plugins, function (plugin) {
      var mimeTypes = map(plugin, function (mimeType) {
        var type = mimeType.type;

        if (mimeType.suffixes) {
          type += '~' + mimeType.suffixes;
        }

        return type;
      });

      return {
        description: plugin.description,
        filename: plugin.filename,
        mimeTypes: mimeTypes,
        name: plugin.name
      };
    });

    return result;
  }

  function collect() {
    function getViewport() {
      var e = window,
        a = 'inner';
      if (!('innerWidth' in window)) {
        a = 'client';
        e = document.documentElement || document.body;
      }
      return { width: e[a + 'Width'], height: e[a + 'Height'] };
    }

    var viewport = getViewport(),
      query = queryString.parse(location.search),
      result = {
        // utmcs Character set (e.g. ISO-8859-1)
        characterSet: document.characterSet || document.charset || document.inputEncoding || 'Unknown',

        // utmsc Screen colour depth (e.g. 24-bit)
        colorDepth: screen.colorDepth + '',

        // gclid Gclid is a globally unique tracking parameter (Google Click Identifier)
        googleClickId: query.gclid || '',

        hash: window.location.hash,
        host: window.location.host,

        // utmhn Hostname
        hostName: window.location.hostname,

        // utmip IP address
        ipAddress: '',

        // utmje Java enabled?
        javaEnabled: navigator.javaEnabled ? navigator.javaEnabled() : false,

        // utmul Language code (e.g. en-us)
        language: window.navigator.userLanguage || window.navigator.language || 'Unknown',

        // login key: ?lk=
        loginKey: query.lk || '',

        // IE9 doesn't support this
        origin: window.location.origin || '',

        // utmp  Page path
        path: window.location.pathname,
        platform: window.navigator.platform,
        plugins: collectPlugins(),
        port: window.location.port || 80,
        // promotional key: pkey
        promotionKey: query.pkey || '',
        protocol: window.location.protocol,

        queryString: window.location.search,

        // utmr  Full referral URL
        referer: document.referrer,

        screenAvailHeight: screen.availHeight,
        screenAvailWidth: screen.availWidth,
        screenHeight: screen.height,
        screenOrientationAngle: '',
        screenOrientationType: '',
        screenPixelDepth: screen.pixelDepth + '',
        // utmsr Screen resolution
        screenResolution: screen.width + 'x' + screen.height,
        screenWidth: screen.width,

        // utmdt Page title
        title: document.title,

        url: window.location.href,
        userAgent: window.navigator.userAgent,
        utmCampaign: query.utm_campaign || '',
        utmContent: query.utm_content || '',
        utmMedium: query.utm_medium || '',
        utmSource: query.utm_source || '',
        utmTerm: query.utm_term || '',

        // utmvp Viewport resolution
        viewportHeight: viewport.height,
        viewportResolution: viewport.width + 'x' + viewport.height,
        viewportWidth: viewport.width
      },
      intFields = [
        'port',
        'screenAvailHeight',
        'screenAvailWidth',
        'screenHeight',
        'screenOrientationAngle',
        'screenWidth',
        'viewportHeight',
        'viewportWidth'
      ],
      prop,
      value;

    // some browsers don't support navigator.javaEnabled(), it's always undefined.
    if (result.javaEnabled === undefined) {
      result.javaEnabled = false;
    }

    // IE 8, 9 don't support this. Yay.
    if (screen.orientation) {
      result.screenOrientationAngle = parseInt(screen.orientation.angle ? screen.orientation.angle : '0');
      result.screenOrientationType = screen.orientation.type ? screen.orientation.type : '';

      if (isNaN(result.screenOrientationAngle)) {
        result.screenOrientationAngle = 0;
      }
    }

    // assert that these values are ints
    for (var i = 0; i < intFields.length; i++) {
      prop = intFields[i];
      value = parseInt(result[prop]);

      if (isNaN(value)) {
        value = 0;
      }

      result[prop] = value;
    }

    return result;
  }

  /**
   * @private
   * @method session
   *
   * @note
   * Gumshoe Session Rules
   *
   *  Generate a new Session ID if any of the following criteria are met:
   *
   *  1. User opens new tab or window (browser default behavior)
   *  2. User has been inactive longer than 30 minutes
   *  3. User has visited withinin the same session, but a UTM
   *     query string parameter has changed.
   */
  function session(fn) {
    // returns a simple object containing utm parameters
    function getUtm() {
      return {
        campaign: query.utm_campaign || '',
        medium: query.utm_medium || '',
        source: query.utm_source || '',
        utmTerm: query.utm_term || ''
      };
    }

    var now = new Date().getTime(),
      query = queryString.parse(location.search),
      lastUtm = storage('utm') || getUtm(),
      utm = getUtm(),
      timestamp,
      difference;

    // save the current state of the utm parameters
    storage('utm', utm);

    // set a session based uuid
    if (!storage('uuid')) {
      storage('uuid', uuidv4());
      storage('timestamp', now);
    } else {
      timestamp = storage('timestamp');
      difference = now - timestamp;

      if (fn) {
        /* jshint validthis: true */
        if (fn.call(this, timestamp, difference, query)) {
          storage('uuid', uuidv4());
        }
      } else if (JSON.stringify(lastUtm) !== JSON.stringify(utm) || difference > 1000 * 60 * 30) {
        storage('uuid', uuidv4());
      }
    }
  }

  function send(eventName, eventData, additional) {
    var pageData = collect(),
      baseData = {
        clientUuid: gumshoe.options.clientUuid,
        eventName: eventName,
        eventData: eventData || {},
        gumshoe: '0.8.1',
        pageData: pageData,
        sessionUuid: storage('uuid'),
        timestamp: new Date().getTime(),
        timezoneOffset: new Date().getTimezoneOffset(),
        uuid: uuidv4()
      },
      transportFound = false;

    // since we're dealing with timeouts now, we need to reassert the
    // session ID for each event sent.
    session(gumshoe.options.sessionFn);

    if (gumshoe.options.transport) {
      for (var i = 0; i < gumshoe.options.transport.length; i++) {
        var transportName = gumshoe.options.transport[i],
          transport,
          data;

        if (transportName && transports[transportName]) {
          transportFound = true;
          transport = transports[transportName];

          // allow each transport to extend the data with more information
          // or transform it how they'd like. transports cannot however,
          // modify eventData sent from the client.
          data = transport.map ? transport.map(baseData, additional) : baseData;

          // extend our data with whatever came back from the transport
          data = extend(baseData, data);

          // TODO: remove this. gumshoe shouldn't care what format this is in
          if (!isString(data.eventData)) {
            data.eventData = JSON.stringify(data.eventData);
          }

          // TODO: remove this. gumshoe shouldn't care what format this is in
          if (!isString(data.pageData.plugins)) {
            data.pageData.plugins = JSON.stringify(data.pageData.plugins);
          }

          // TODO: remove this. temporary bugfix for apps
          if (!data.pageData.ipAddress) {
            data.pageData.ipAddress = '<unknown>';
          }

          pushEvent(eventName, transportName, data);
        } else {
          throw 'Gumshoe: The transport name: ' + transportName + ", doesn't map to a valid transport.";
        }
      }
    }

    /*if (!transportFound) {
      throw 'Gumshoe: No valid transports were found.';
    }*/
  }

  function nextEvent() {
    if (!queue.length) {
      return;
    }

    // granb the next event from the queue and remove it.
    var nevent = queue.shift(),
      transport = transports[nevent.transportName];

    storage('queue', queue);
    transport.send(nevent.data, function (err, result) {
      // we care if an error was thrown, created, or captured
      // if there is an error, add the item back into the queue
      if (err) {
        console.warn(
          'Gumshoe: Retrying. Error received from transport: ' +
            nevent.transportName +
            ', for event: ' +
            nevent.eventName
        );
        queue.push(nevent);
      }
    });

    setTimeout(nextEvent, gumshoe.options.queueTimeout);
  }

  function pushEvent(eventName, transportName, data) {
    var transport;

    // if we're dealing with a fake storage object
    // (eg. sessionStorage isn't available) then don't
    // even bother queueing the data.
    if (storage.isFake()) {
      transport = transports[transportName];
      transport.send(data);

      return;
    }

    // add the event data to the queue
    queue.push({
      eventName: eventName,
      transportName: transportName,
      data: data
    });

    // put our newly modified queue in session storage
    storage('queue', queue);

    setTimeout(nextEvent, gumshoe.options.queueTimeout);
  }

  function transport(tp) {
    if (!tp.name) {
      throw 'Gumshoe: Transport [Object] must have a name defined.';
    }

    transports[tp.name] = tp;
  }

  // setup some static properties
  gumshoe.version = '0.8.1';
  gumshoe.options = {};

  // setup some static methods
  gumshoe.extend = extend;
  gumshoe.reqwest = context.reqwest;
  gumshoe.send = send;
  gumshoe.transport = transport;
  gumshoe.uuid = uuidv4;

  // setup some internal stuff for access
  gumshoe._ = {
    collect: collect,
    localStorage: localStore,
    queryString: queryString,
    queue: queue,
    storage: storage,
    transports: transports
  };

  return gumshoe;

  /*
  if (root.gumshoe) {
    if (root.gumshoe.ready) {
      root.gumshoe.ready = gumshoe.ready = root.gumshoe.ready;
      root.gumshoe = gumshoe;

      if (!isFunction(root.gumshoe.ready.resolve)) {
        throw 'Gumshoe: gumshoe.ready was predefined, but is not a Promise/A deferred.';
      }

      root.gumshoe.ready.resolve();
    }
  }
  else {
    root.gumshoe = gumshoe;
  }
  */
}

module.exports = gumshoeFactory;
